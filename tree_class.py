from typing import Dict
import json
from openai import OpenAI
from dotenv import load_dotenv


load_dotenv()

class Tree:
    file_path: str = None
    data: Dict = None

    def __init__(self, file_path: str) -> None:
        """
        Description:
            - Constructor for Tree Data Class. 
            - Takes the filepath and loads json data. 

        Parameters:
            - file_path (str): Path of the json file you wanna read/interpret
        
        Returns:   
            - None
        """

        self.file_path = file_path

        # Load data from the path
        data = self._load_data()
        self.data = data
        self.temp_data = data
        self.client = OpenAI()


    def _load_data(self) -> Dict:
        """
        Description:
            - Internal method that loads json data from a file path.

        Parameters:
            - Self reference 
        
        Returns:
            - data (Dict): Data loaded from the json file path. 
        """

        file_path = self.file_path
        with open(file_path, 'r') as json_data:
            data = json.load(json_data)

        return data
    
    def _get_best_matching_key(self, data, input, gpt_key_values) -> Dict:
        """
        Description:
            - This function takes the data, query and returns which key matches the best to our query. 
        
        Parameters:
            - data (Dict): Dictionary of the data to be searched. 
            - input (str): Query that is to be searched
            - gpt_key_values (arr): Key values from which the answer is to be derived. 

        Returns:
            - result (str): The best key matching to the required inputs. 
        """
        system_prompt = f"""
        You will be given an array of objects having keys namely "node_name" and "children" in: {data}. You have to match the "children" with {input} and return the the exact "node_name"


        Here are a couple of terms:
        1. Standalone TP or TP or Third Party = SATP or TP
        2. Standalone OD or OD or Own Damage = SAOD or OD 
        3. Comprehensive or Comp or Package = Package
        4. Power of the vehicle may or may not have cc in the end, it is your job to assume it. 
        5. Private car may be written as PC and Two wheeler might be written as TW or 2W or 2 Wheeler

        Note:
        Just return the node_name and no extra text.
        """

        user_prompt = f""" You will be given an array of objects having keys namely "node_name" and "children": {data}. You have to match the "children" with {input} and return the the exact "node_name" from {gpt_key_values} only Without any extra text and without quotes: '' . Ignore any input fields that are not applicable."""
        completion = self.client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ]
        )

        result = completion.choices[0].message.content

        return result

    def _tree_traversal(self, input):
        """
        Description:
            - This function traverses the tree and returns the best key
        
        Parameters:
            - data (Dict): data which is to be traversed
            - input (str): Query which is to be matched in the tree

        returns:
            - result (Dict): Dictionary of the best key
        """

        nodes = []
        # print("Working: ", data) UNCOMMENT WHILE DEBUGGING
        for key, value in self.temp_data.items():
            children = []
            if isinstance(value, dict):
                for k in value.keys():
                    children.append(k)
        
            nodes.append({
                "node_name": key, 
                "children": children
            })
        
        # Generate Best key from nodes array
        # print(nodes) UNCOMMENT WHLIE DEBUGGING
        
        # Key values for Open AI
        gpt_key_values = [node['node_name'] for node in nodes]
        best_key = self._get_best_matching_key(nodes, input, gpt_key_values)
        # print("Best Key", best_key) UNCOMMENT WHILE DEBUGGIN
        next_level = self.temp_data[best_key]
        
        # Traverse the tree for the best key and check if the best key node is second last (has values), if yes return that
        if isinstance(next_level, dict):
            if any(isinstance(val, dict) for val in next_level.values()):
                self.temp_data = next_level
                return self._tree_traversal(input)
            else:
                return next_level
        else:
            return next_level
        

    def get_commision_rate(self, input):
        """
        Description:
            - This function takes the answer generated by the tree_traversal function and returns a final answer based on our input query. 

        Parameters:
            - input (str): Input Query String 
        
        Returns:
            - commision_rate (float): Commision rate
        """
        commision = self._tree_traversal(input)
        system_prompt = f"You will be given an output, based on the input query: {input}, return the commision rate applicable from: {commision}. Just return the number and no extra text."

        user_prompt = f"For the given commision rate: {commision}. Find the commision rate for the given input query: {input}. Just return the commision rate number and no extra text."
        completion = self.client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ]
        )

        result = completion.choices[0].message.content
        result_type = type(result)

        return float(result)


        